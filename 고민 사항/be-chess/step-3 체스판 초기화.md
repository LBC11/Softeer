## 구현 내용
- Pawn class
  + representation field 추가
  + field에 대한 접근 제어자 private로 수정
- Board class
  + map을 사용해 보드판 구현
  + ArrayList를 사용해 현재 보드판에 있는 기물들을 저장
  + print() 구현
- Chess class
  + start() 구현
  + end() 구현
- Main class 구현

## 고민 사항
- 학습 목표중 하나인 2차원 배열의 대안을 생각해보자
  + 알고리즘을 공부하면서 n차원 배열을 더 낮은 차원으로 이끌어 내야 하는 상황이 많이 있었다.
  + 그 당시 hash등의 방법을 사용했는데 이와 비슷하게 접근해보았다.
  + 먼저 idx의 범위가 0~7이므로 row * 10 + col을 idx로 사용하는 1차원 배열을 떠올렸다.
  + 그런데 중간중간 낭비되는 메모리 공간이 생기게 된다. 이 때문에 map을 사용해서 해결하였다.
- 중복 제거에 대한 그동안의 오해
  + 사실 미션에서 상수를 선언하여 중복을 제거하라고 했을 때 긴가민가 했었다.
  + 해당 부분의 코드양이 줄거나 변화가 없었기 때문에 굳이?? 라고 생각했다.
  + 하지만 고민하다보니 상수를 사용하는 것은 해당 변수를 선언하고, 사용되고, gc에 의해 제거되는 일련의 활동이 반복되고 있다는 것을 꺠달았다.
  + 앞으로 리팩토링을 할 때 눈에 보이는 코드의 중복만을 제거하는 것이 아니라 코드가 실제로 구동될 때 발생하는 중복도 제거하기 위해 고민해야 겠다.
- 현재 사용하지 않는 함수들은 어떻게 해야 하는가?
  + 현재의 미션 단계에서 Board class의 add()등의 함수들은 사용되지 않고 있다.
  + 물론, 미션을 진행하면서 해당 부분을 수정하고 다시 재사용할 가능성이 크지만 그 전까지 해당 부분들을 어떻게 관리해야하는지 고민해보았다.
  + 나중을 위해 단순히 방치하거나 주석처리를 해야 하는 걸까? 아니면 삭제하고 코드의 가독성을 늘려야 하는걸까?
  + 이 부분에 대해서는 고민이 더 필요하다.
- 10년 후 미래의 내가 얼마나 빠르게 지금 작성하는 코드를 이해할까?
  + 부트 캠프에 참여하면서 다짐했던 것이 최대한 고민하고 또 고민해서 단순히 흘려넘기지 말자였다.
  + 그러다보니 많은 부분에서 인식변화가 생겼는데, 접근 제어자는 그 중 하나이다.
  + 기존에는 혼자 코딩하는 경우가 많아 크게 신경쓰지 않았었다.
  + 객체의 자율성을 위해서 분명히 선언하는 것이 좋다고는 알고 있었지만 외부에서 접근 안 하면 되지 라는 마인드 였던 것 같다.
  + 그래서 예전에 작성했던 코드를 보았는데, 이해가 많이 어려웠다...
  + 코딩은 협업이고 같이 하는 것이다. 10년 후의 내가 이해하기 편하게 코딩한다고 생각하자.
- start(), end() 함수들은 어디 있어야 할까?
  + 처음에는 board class에 추가하려고 했다.
  + 프로그램은 현실세계의 모방이 아니라 새로운 창조라고 하지만 이해가 쉬운 코드를 작성하기 위해서는 어느 정도 모방해야 한다고 생각이 들었다.
  + 그래서 보드판을 담당하는 class에 게임을 시작하고 끝내는 기능을 넣는것이 맞지 않다고 생각해서 chess class를 하나 새롭게 구현하였다.

## 기타
